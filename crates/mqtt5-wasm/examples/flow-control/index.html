<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MQTT Flow Control Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 40px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .header {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 { color: #333; margin-top: 0; }
        .highlight {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #007bff;
            margin: 15px 0;
        }
        .highlight.warning {
            background: #fff3cd;
            border-left-color: #ffc107;
        }
        .panels {
            display: grid;
            grid-template-columns: 1fr 200px 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .panel h2 {
            margin-top: 0;
            font-size: 1.2em;
            padding-bottom: 10px;
        }
        .panel.publisher h2 { border-bottom: 3px solid #fd7e14; }
        .panel.subscriber h2 { border-bottom: 3px solid #28a745; }
        .panel.flow { background: #f8f9fa; text-align: center; }
        .status {
            padding: 8px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: 500;
            font-size: 0.85em;
        }
        .status.connected { background: #d4edda; color: #155724; }
        .status.disconnected { background: #f8d7da; color: #721c24; }
        .status.blocked { background: #fff3cd; color: #856404; }
        button {
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
            margin: 5px 5px 5px 0;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        button.start { background: #28a745; }
        button.start:hover { background: #218838; }
        button.stop { background: #dc3545; }
        button.stop:hover { background: #c82333; }
        .quota-meter {
            background: #e9ecef;
            border-radius: 10px;
            height: 30px;
            margin: 20px 0;
            overflow: hidden;
            position: relative;
        }
        .quota-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.2s ease, background 0.2s ease;
        }
        .quota-fill.ok { background: linear-gradient(90deg, #28a745, #20c997); }
        .quota-fill.warning { background: linear-gradient(90deg, #ffc107, #fd7e14); }
        .quota-fill.critical { background: linear-gradient(90deg, #dc3545, #c82333); }
        .quota-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 0.85em;
        }
        .receive-max-display {
            font-size: 3em;
            font-weight: bold;
            color: #007bff;
            margin: 15px 0;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
        }
        .stat-row:last-child { border-bottom: none; }
        .message-queue {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin: 15px 0;
            min-height: 60px;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
        }
        .queue-item {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            animation: queueIn 0.2s ease;
        }
        @keyframes queueIn {
            from { transform: scale(0); }
            to { transform: scale(1); }
        }
        .queue-item.pending { background: #ffc107; }
        .queue-item.acked { background: #28a745; }
        .queue-item.waiting { background: #dc3545; }
        .flow-arrow {
            font-size: 2em;
            color: #28a745;
            margin: 10px 0;
        }
        .flow-arrow.blocked { color: #dc3545; }
        .throughput-chart {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            height: 80px;
            margin-top: 10px;
        }
        .throughput-bar {
            flex: 1;
            background: #007bff;
            min-width: 6px;
            border-radius: 2px 2px 0 0;
            transition: height 0.3s ease;
        }
        .controls-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 15px 0;
        }
        input[type="range"] {
            flex: 1;
        }
        #debug {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.8em;
            max-height: 150px;
            overflow-y: auto;
            display: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>MQTT Flow Control (Backpressure) Demo</h1>
        <p>Demonstrates <strong>MQTT v5.0 Receive Maximum</strong> for flow control and preventing subscriber overwhelm.</p>
        <div class="highlight">
            <strong>How Flow Control Works:</strong>
            <ul style="margin: 10px 0 0 0; padding-left: 20px;">
                <li>Subscriber advertises <code>receiveMaximum</code> (max in-flight QoS 1/2 messages)</li>
                <li>Publisher must wait for ACKs before sending more when quota is exhausted</li>
                <li>This prevents fast publishers from overwhelming slow consumers</li>
            </ul>
        </div>
        <div id="debug">
            <strong>Debug Log:</strong>
            <div id="debug-messages"></div>
        </div>
    </div>

    <div class="panels">
        <div class="panel publisher">
            <h2>Fast Publisher</h2>
            <div id="status-publisher" class="status disconnected">Disconnected</div>

            <div class="controls-row">
                <button id="start-btn" class="start">Start Publishing</button>
                <button id="stop-btn" class="stop" disabled>Stop</button>
            </div>

            <div class="controls-row">
                <span>Publish Rate:</span>
                <input type="range" id="rate-slider" min="1" max="50" value="20">
                <span id="rate-value">20 msg/s</span>
            </div>

            <div class="stat-row">
                <span>Messages Sent:</span>
                <strong id="sent-count">0</strong>
            </div>
            <div class="stat-row">
                <span>ACKs Received:</span>
                <strong id="ack-count">0</strong>
            </div>
            <div class="stat-row">
                <span>Waiting for Quota:</span>
                <strong id="waiting-count">0</strong>
            </div>

            <h4>In-Flight Messages:</h4>
            <div class="message-queue" id="publisher-queue"></div>

            <h4>Throughput (msg/s):</h4>
            <div class="throughput-chart" id="throughput-chart"></div>
        </div>

        <div class="panel flow">
            <h3>Flow Control</h3>
            <div class="flow-arrow" id="flow-arrow">→</div>

            <div style="margin: 20px 0;">
                <div style="font-size: 0.9em; color: #666;">Receive Maximum</div>
                <div class="receive-max-display" id="receive-max">5</div>
            </div>

            <div class="quota-meter">
                <div class="quota-fill ok" id="quota-fill" style="width: 100%"></div>
                <div class="quota-text" id="quota-text">5 / 5</div>
            </div>

            <div class="controls-row">
                <span>Max:</span>
                <input type="range" id="max-slider" min="1" max="20" value="5">
            </div>

            <div id="backpressure-indicator" class="highlight warning" style="display: none; margin-top: 15px;">
                <strong>Backpressure Active!</strong>
                <div style="font-size: 0.85em;">Publisher waiting for ACKs</div>
            </div>
        </div>

        <div class="panel subscriber">
            <h2>Slow Subscriber</h2>
            <div id="status-subscriber" class="status disconnected">Disconnected</div>

            <div class="controls-row">
                <span>Processing Time:</span>
                <input type="range" id="delay-slider" min="50" max="1000" value="200">
                <span id="delay-value">200ms</span>
            </div>

            <div class="stat-row">
                <span>Messages Received:</span>
                <strong id="received-count">0</strong>
            </div>
            <div class="stat-row">
                <span>ACKs Sent:</span>
                <strong id="ack-sent-count">0</strong>
            </div>
            <div class="stat-row">
                <span>Processing Queue:</span>
                <strong id="processing-queue">0</strong>
            </div>

            <h4>Processing Queue:</h4>
            <div class="message-queue" id="subscriber-queue"></div>
        </div>
    </div>

    <script type="module">
        import init, { WasmBroker, WasmBrokerConfig, WasmMqttClient, WasmConnectOptions } from './pkg/mqtt5_wasm.js';

        let broker;
        let publisherClient;
        let subscriberClient;
        let publishInterval = null;

        let receiveMaximum = 5;
        let processingDelay = 200;
        let publishRate = 20;

        const stats = {
            sent: 0,
            acks: 0,
            waiting: 0,
            received: 0,
            acksSent: 0
        };

        const inFlight = new Set();
        const processingQueue = [];
        const throughputHistory = new Array(30).fill(0);
        let messagesThisSecond = 0;

        function debugLog(msg) {
            const debugDiv = document.getElementById('debug');
            const messagesDiv = document.getElementById('debug-messages');
            debugDiv.style.display = 'block';
            const line = document.createElement('div');
            line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            messagesDiv.appendChild(line);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            console.log(msg);
        }

        function updateDisplay() {
            document.getElementById('sent-count').textContent = stats.sent;
            document.getElementById('ack-count').textContent = stats.acks;
            document.getElementById('waiting-count').textContent = stats.waiting;
            document.getElementById('received-count').textContent = stats.received;
            document.getElementById('ack-sent-count').textContent = stats.acksSent;
            document.getElementById('processing-queue').textContent = processingQueue.length;

            const available = Math.max(0, receiveMaximum - inFlight.size);
            const percent = (available / receiveMaximum) * 100;
            const fill = document.getElementById('quota-fill');
            fill.style.width = `${percent}%`;
            fill.className = `quota-fill ${percent > 50 ? 'ok' : percent > 20 ? 'warning' : 'critical'}`;
            document.getElementById('quota-text').textContent = `${available} / ${receiveMaximum}`;

            const arrow = document.getElementById('flow-arrow');
            const indicator = document.getElementById('backpressure-indicator');
            if (available === 0) {
                arrow.textContent = '✗';
                arrow.className = 'flow-arrow blocked';
                indicator.style.display = 'block';
            } else {
                arrow.textContent = '→';
                arrow.className = 'flow-arrow';
                indicator.style.display = 'none';
            }

            const pubQueue = document.getElementById('publisher-queue');
            pubQueue.innerHTML = '';
            inFlight.forEach(id => {
                const item = document.createElement('div');
                item.className = 'queue-item pending';
                item.title = `Message ${id}`;
                pubQueue.appendChild(item);
            });

            for (let i = 0; i < stats.waiting; i++) {
                const item = document.createElement('div');
                item.className = 'queue-item waiting';
                pubQueue.appendChild(item);
            }

            const subQueue = document.getElementById('subscriber-queue');
            subQueue.innerHTML = '';
            processingQueue.forEach(id => {
                const item = document.createElement('div');
                item.className = 'queue-item pending';
                subQueue.appendChild(item);
            });
        }

        function updateThroughputChart() {
            throughputHistory.push(messagesThisSecond);
            throughputHistory.shift();
            messagesThisSecond = 0;

            const max = Math.max(...throughputHistory, 1);
            const chart = document.getElementById('throughput-chart');
            chart.innerHTML = '';

            throughputHistory.forEach(val => {
                const bar = document.createElement('div');
                bar.className = 'throughput-bar';
                bar.style.height = `${(val / max) * 100}%`;
                chart.appendChild(bar);
            });
        }

        let messageIdCounter = 0;

        async function publishMessage() {
            const available = receiveMaximum - inFlight.size;
            if (available <= 0) {
                stats.waiting++;
                updateDisplay();
                return false;
            }

            messageIdCounter++;
            const msgId = messageIdCounter;
            inFlight.add(msgId);
            stats.sent++;
            stats.waiting = Math.max(0, stats.waiting - 1);

            const encoder = new TextEncoder();
            const payload = JSON.stringify({ id: msgId, timestamp: Date.now() });

            await publisherClient.publish_qos1('flow/test', encoder.encode(payload));
            messagesThisSecond++;
            updateDisplay();
            return true;
        }

        async function processMessage(msgId) {
            processingQueue.push(msgId);
            updateDisplay();

            await new Promise(r => setTimeout(r, processingDelay));

            const index = processingQueue.indexOf(msgId);
            if (index > -1) processingQueue.splice(index, 1);

            inFlight.delete(msgId);
            stats.acks++;
            stats.acksSent++;
            updateDisplay();
        }

        async function main() {
            try {
                debugLog('Initializing WASM...');
                await init();

                const config = new WasmBrokerConfig();
                config.max_clients = 10;
                config.allow_anonymous = true;

                broker = WasmBroker.with_config(config);
                debugLog('Broker created');

                subscriberClient = new WasmMqttClient('slow-subscriber');
                subscriberClient.on_connect(() => {
                    document.getElementById('status-subscriber').className = 'status connected';
                    document.getElementById('status-subscriber').textContent = 'Connected';
                });

                const subPort = broker.create_client_port();
                const subOptions = new WasmConnectOptions();
                subOptions.receiveMaximum = receiveMaximum;
                await subscriberClient.connect_message_port_with_options(subPort, subOptions);

                await subscriberClient.subscribe_with_callback('flow/test', (topic, payload) => {
                    const decoder = new TextDecoder();
                    const data = JSON.parse(decoder.decode(payload));
                    stats.received++;
                    processMessage(data.id);
                });

                debugLog('Subscriber connected with receiveMaximum=' + receiveMaximum);

                publisherClient = new WasmMqttClient('fast-publisher');
                publisherClient.on_connect(() => {
                    document.getElementById('status-publisher').className = 'status connected';
                    document.getElementById('status-publisher').textContent = 'Connected';
                });

                const pubPort = broker.create_client_port();
                await publisherClient.connect_message_port(pubPort);
                debugLog('Publisher connected');

                document.getElementById('start-btn').addEventListener('click', () => {
                    if (publishInterval) return;

                    const interval = 1000 / publishRate;
                    publishInterval = setInterval(() => publishMessage(), interval);

                    document.getElementById('start-btn').disabled = true;
                    document.getElementById('stop-btn').disabled = false;
                    debugLog('Started publishing at ' + publishRate + ' msg/s');
                });

                document.getElementById('stop-btn').addEventListener('click', () => {
                    if (publishInterval) {
                        clearInterval(publishInterval);
                        publishInterval = null;
                    }
                    document.getElementById('start-btn').disabled = false;
                    document.getElementById('stop-btn').disabled = true;
                    debugLog('Stopped publishing');
                });

                document.getElementById('rate-slider').addEventListener('input', (e) => {
                    publishRate = parseInt(e.target.value);
                    document.getElementById('rate-value').textContent = publishRate + ' msg/s';

                    if (publishInterval) {
                        clearInterval(publishInterval);
                        const interval = 1000 / publishRate;
                        publishInterval = setInterval(() => publishMessage(), interval);
                    }
                });

                document.getElementById('delay-slider').addEventListener('input', (e) => {
                    processingDelay = parseInt(e.target.value);
                    document.getElementById('delay-value').textContent = processingDelay + 'ms';
                });

                document.getElementById('max-slider').addEventListener('input', (e) => {
                    receiveMaximum = parseInt(e.target.value);
                    document.getElementById('receive-max').textContent = receiveMaximum;
                    updateDisplay();
                });

                setInterval(updateThroughputChart, 1000);

                debugLog('Demo ready! Click "Start Publishing" and adjust sliders.');
            } catch (error) {
                debugLog(`ERROR: ${error.message || error}`);
                console.error('Initialization error:', error);
            }
        }

        main();
    </script>
</body>
</html>
